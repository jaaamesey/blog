After [my first post](/posts/use_state_should_require_a_dependency_array), I would never have thought that:

1. the second would be about another React hook
2. it would be about `useEffect`
3. I would be *defending* `useEffect` *(well, just a little...)*

I'm like two weeks late to this, but in case you hadn't heard the news:

[Cloudflare's dashboard and API got DDOSed](https://blog.cloudflare.com/deep-dive-into-cloudflares-sept-12-dashboard-and-api-outage/). 

By their own codebase.

Because of a `useEffect`.

...sorta.


Disclaimer: I'm literally just some guy, I have no affiliation with Cloudflare (aside from freeloading off of their very generous free tier for Workers), and I can't say I have enough backend expertise to talk about what could have gone better there.

I also have nothing to do with the React dev team and do not hold a license to practice medicine.

Sidenote: If you don't know what `useEffect` is...

...I envy you. I really do.

[Here's the official docs.](https://react.dev/reference/react/useEffect)

Basically, it's a way for a component to detect changes to data it sees (whether that's from props, state, or elsewhere), and respond to that in some way. Maybe it's even just reacting to the fact that the component "exists" (i.e. whether it's mounted/unmounted). 

It's not like this API doesn't exist for a good reason. Components in React are declarative, but at some point they'll probably need to do some imperative thing, like listen for keyboard shortcuts, or fetch some data from a server.

Anyway, here's how Cloudflare explained the outage:

> The incident’s impact stemmed from several issues, but the immediate trigger was a bug in the dashboard. This bug caused repeated, unnecessary calls to the Tenant Service API. The API calls were managed by a React useEffect hook, but we mistakenly included a <mark>problematic object in its dependency array</mark>. Because <mark>this object was recreated on every state or prop change</mark>, React treated it as “always new,” causing the useEffect to re-run each time. As a result, <mark>the API call executed many times during a single dashboard render instead of just once</mark>.

From this we can assume the cause to be an object created on each render of a component, that's somehow made its way to a `useEffect` dependency array.

So, the culprit was some React code that might have looked a bit like this:

```tsx
function SomeDashboard({ page, sortBy... }) {
    const [fetchedData, setFetchedData] = useState([]);
    
    // Our unstable object
    const requestParams = { 
        page, 
        sortBy, 
        source: 'some_dashboard', 
        ...
    };

    // Our effect, run each time this component renders!
    useEffect(() => {
        fetchData(requestParams).then(data => setFetchedData(data));
    }, [requestParams]);  

    return <div>{fetchedData.map(...)}</div>;
}
```


When this component renders, it:

1. creates a new `requestParams` object to store request parameters
2. detects if this render's `requestParams` is different from the previous render's `requestParams` object
3. realizes that `requestParams` is new (it always is - in JavaScript, objects are pass by reference)
4. responds by calling `fetchData`

Then, when that request resolves, the component updates its internal state to reflect the new data coming in.

This requires another render. We then return to step 1, and continue this horrible loop.




Of course, this example is taking some artistic license in a few places. 

For example, we don't now how far away the object's creation was from the `useEffect` call. Here they're both in the same component, but it could have very well have been passed through several layers of prop drilling. 

We also don't know that the request resolving is what always caused the next render. In React, you can (and should) expect a re-render to be caused by pretty much anything. Maybe it was worse. Maybe it was better.

Maybe there was a timer in the component that ticked every second. Maybe it was flu season and their `useSneezeListener` hook kept picking things up.

Point is, network requests were being repeated with such frequency that it brought down their backend.


import {EmbedReactComponent} from '~/utils/embed_react_component';
import {DemoWrapper} from '~/utils/demo_wrapper';

<DemoWrapper>
<EmbedReactComponent loader={() => import('./use_effect_bad.react').then(r=>r.UseEffectBad)}/>
</DemoWrapper>

...let's just leave it running and hope nobody notices.

## How much can we blame the `useEffect` API?

Not much. There's some other things around `useEffect` that [I think are questionable](https://react.dev/reference/react/useEffect#my-effect-runs-twice-when-the-component-mounts), 
but the core concept of "detect changes and respond to them" is something you see in nearly [every](https://svelte.dev/docs/svelte/$effect) [other](https://docs.solidjs.com/reference/basic-reactivity/create-effect) [framework](https://vuejs.org/guide/essentials/watchers).

You might say "well, the [lint rules](https://stackoverflow.com/questions/58866796/understanding-the-react-hooks-exhaustive-deps-lint-rule) force me to put things in the dependency array that shouldn't be there!".
And you'd be right. We could just remove the problematic object from the dependency array, and not have it get stuck in a loop.

```tsx {15-16}
function SomeDashboard({ page, sortBy... }) {
    const [fetchedData, setFetchedData] = useState([]);
    
    const requestParams = { ... };

    useEffect(() => {
        fetchData(requestParams).then(data => setFetchedData(data));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);  

    return <div>{fetchedData.map(...)}</div>;
}
```

But other frameworks are arguably stricter and more opaque about this. Svelte's `$effect` doesn't even ask for a dependency array, it just automatically listens to *everything it sees* in the effect function. There's still escape hatches of course, but the core philosophy of everything being tracked by default is by no means unique to React. 

## How much can we blame the victim?

A little. A `useMemo` would fix this by making the object more stable between renders:

```tsx
function SomeDashboard({ page, sortBy... }) {
    const [fetchedData, setFetchedData] = useState([]);
    
    // Our now fairly stable object
    const requestParams = useMemo(() => ({ 
        page, 
        sortBy, 
        source: 'some_dashboard', 
        ...
    }), [page, sortBy, ...]);

    // No longer runs literally every render!
    useEffect(() => {
        fetchData(requestParams).then(data => setFetchedData(data));
    }, [requestParams]);  

    return <div>{fetchedData.map(...)}</div>;
}
```

In fact if they were using the [React Compiler](https://react.dev/learn/react-compiler), they wouldn't even have to wrap anything in a `useMemo` in the first place.

But even if this is stable in practice right now, React insists that [its memoization isn't a semantic guarantee](https://react.dev/reference/react/useMemo#preventing-an-effect-from-firing-too-often) - that it's something you should be seeing more as a performance optimization that may or may not decide to kick in.

Maybe they should have just created the object inside the `useEffect` itself?

```tsx {15-16}
function SomeDashboard({ page, sortBy... }) {
    const [fetchedData, setFetchedData] = useState([]);

    useEffect(() => {
        const requestParams = { ... };
        fetchData(requestParams).then(data => setFetchedData(data));
    }, [page, sortBy, ...]);  

    return <div>{fetchedData.map(...)}</div>;
}
```

But I'm sure there's some cases where this isn't realistic.

Could this have been caught by a linter? Maybe, for very simple cases - but I'd imagine it'd be difficult, perhaps impossible to catch anything crossing component boundaries.

The one area I will throw shade at is the fact that they're not using something like Tanstack Query. Data fetching (or more specifically, managing the state around it) can be a lot more complex than people anticipate, and one of the things it has is a [dependency array that's effectively pass by value instead of pass by reference](https://tanstack.com/query/v4/docs/framework/react/guides/query-keys#query-keys-are-hashed-deterministically).

In other words: <u>Tanstack Query would have prevented this</u>. Maybe part of that is on React for not having built-in primitives like [createResource](https://docs.solidjs.com/reference/basic-reactivity/create-resource), though.

## ...what else can we blame, then?

The one thing that sets React apart from more modern frameworks like Svelte and Solid is its rendering model.

It's easy to forget that React has been around for well over a decade. This syntax would have been really, really sought after back then:

```tsx
function Counter() {
    const [count, setCount] = useState(0);
    return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

A Virtual DOM is a really easy way to represent UI in a way that isn't absolutely horrible. Core language primitives like if/else and arrays become how you handle conditional rendering and lists. Even native iOS and Android UI these days (i.e. through SwiftUI and Jetpack Compose) is built on top of a similar model.

When most people talk about the shortfalls of this model, it's about performance - the fact that we're doing a ton of unnecessary recomputation each time any piece of state changes.

Performance is obviously important. Any signals-based framework (e.g. Solid and now Svelte) is probably going to outperform this model by a landslide.

But the other problem here is that anything declared inside a component is, by default, ephemeral. 

A regular old `const` is not really "constant", in that it won't persist between renders. 

Any functions you define are going to be constantly re-created.

It's not `useEffect` itself - it's this natural *instability* that makes dealing with it so much worse than its equivalent in other frameworks.

To be fair, React likely shares this problem with fully immediate mode renderers like [imgui](https://github.com/ocornut/imgui). We just don't usually put renderers like that under the stress of tying state and side effects to individual widgets.

You don't have to shift a ton of code around to write equivalent code that *doesn't* break in something like Solid or Svelte:

```tsx
function SomeDashboardButInSolidJS(props) {
    const [fetchedData, setFetchedData] = createSignal([]);
    
    // This needs to be a getter function, because this is only declared once
    const requestParams = () => ({ 
        page, 
        sortBy, 
        source: 'some_dashboard', 
        ...
    }); 

    // createResource would be the right tool for this, but I'm trying to get it as close to vanilla React as possible
    createEffect(() => {
        fetchData(requestParams()).then(data => setFetchedData(data));
    });

    return <div>{fetchedData().map(...)}</div>;
}
```

Of course, in Solid's case, this comes at the cost of its state model requiring more annoying syntax.

But if we're going to blame React for something, I'd blame its rendering model more than `useEffect` here.






